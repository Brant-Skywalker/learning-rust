fn main() {
    // What is a String?
    // Rust has only one string type in the core language, which is the string slice
    // `str` that is usually seen in its borrowed form `&str`.
    // *String slices* are references to some UTF-8 encoded string data stored elsewhere.

    // The `String` type, which is provided by Rust's standard library rather than coded into
    // the core language, is a growable, mutable, owned, UTF-8 encoded string type.

    // Both `String` and string slices are UTF-8 encoded.

    // Creating a New String
    // Many of the same operations available with `Vec<T>` are available with `String` as well,
    // starting with the `new` function to create a string.
    let mut s = String::new();
    // This line creates a new empty string called `s`, which we can then load data into.

    // If we have some initial data that we want to start the string with, use the `to_string`
    // method, which is available on any type that implements the `Display` trait, as string
    // literals do.
    let data = "initial contents";
    let s = data.to_string();
    // The method also works on a literal directly:
    let s = "initial contents".to_string();

    // We can also use the function `String::from` to create a `String` from a string literal.
    let s = String::from("initial contents");

    // Because strings are used for so many things, we can use many different generic APIs for
    // strings, providing us with a lot of options.

    // Strings are UTF-8 encoded, so we can include any properly encoded data in them.
    let hello = String::from("السلام عليكم");
    let hello = String::from("Dobrý den");
    let hello = String::from("Hello");
    let hello = String::from("שָׁלוֹם");
    let hello = String::from("नमस्ते");
    let hello = String::from("こんにちは");
    let hello = String::from("안녕하세요");
    let hello = String::from("你好");
    let hello = String::from("Olá");
    let hello = String::from("Здравствуйте");
    let hello = String::from("Hola");
    // All of these are valid `String` values.

    // Updating a String
    // A `String` can grow in size and its contents can change, just like the contents of a `Vec<T>`,
    // if we push more data into it.
    // In addition, we can conveniently use the `+` operator or the `format!` macro to concatenate 
    // `String` values.

    // Appending to a String with `push_str` and `push`.
    // We can grow a `String` by using the `push_str` method to append a string slice.
    let mut s = String::from("foo");
    s.push_str("bar");
    println!("{}", s);
    // The `push_str` method takes a string slice because we don't necessarily want to take 
    // ownership of the parameter.
    let mut s1 = String::from("foo");
    let s2 = "bar";
    s1.push_str(s2);
    println!("s2 is {}", s2);

    // The `push` method takes a single character as a parameter and adds it to the `String`.
    let mut s = String::from("lo");
    s.push('l');
    println!("{}", s);

    // Concatenation with the `+` Operator or the `format!` Macro
    let s1 = String::from("Hello, ");  // Later moved into the `add` call.
    let s2 = String::from("world!");
    let s3 = s1 + &s2;
    // The reason `s1` is no longer valid after the addition, and the reason we used a reference
    // to `s2`, has to do with the signature of the method that's called when we use the `+`
    // operator. The `+` operator uses the `add` method, whose signature looks something like this:
    // fn add(self, s: &str) -> String {
    // `add` is defined using generics.

    // The reason we're able to use `&s2` in the call to `add` is that the compiler can *coerce*
    // the `&String` argument into a `&str`. When we call the `add` method, Rust uses a *deref
    // coercion*, which here turns `&s2` into `&s2[..]`.

    // `add` takes ownership of `self`, because `self` does not have an `&`.

    // If we need to concatenate multiple strings, the behavior of the `+` operator gets unwieldy.
    let s1 = String::from("tic");
    let s2 = String::from("tac");
    let s3 = String::from("toe");

    let s = s1 + "-" + &s2 + "-" + &s3;
    println!("{}", s);

    // For more complicated string combining, we can instead use the `format!` macro.
    let s1 = String::from("tic");
    let s2 = String::from("tac");
    let s3 = String::from("toe");
    let s = format!("{}-{}-{}", s1, s2, s3);
    println!("{}", s);
    // The `format!` macro returns a `String` with the contents. The version of code using `format!`
    // is much easier to read, and the code generated by the `format!` macro uses references so that
    // this call doesn't take ownership of any of its parameters.

    // Indexing into Strings
    // If we try to access parts of a `String` using indexing syntax in Rust, we'll get an error.
    // let s1 = String::from("hello");
    // let h = s1[0];
    // Rust strings don't support indexing.

    // Internal Representation
    // A `String` is a wrapper over a `Vec<u8>`.
    let hello = String::from("Hola");
    println!("{}", hello.len());
    // In this case, `len` will be 4, which means the vector storing the string "Hola" is 4 bytes
    // long. Each of these letters takes 1 byte when encoded in UTF-8.

    let hello = String::from("Здравствуйте");
    println!("{}", hello.len());  // 24.
    // Each Unicode scalar value in this string takes 2 bytes of storage.
    // Therefore, an index into the string's bytes will not always correlate to a valid Unicode
    // scalar value.

    // Bytes and Scalar Values and Grapheme Clusters!

    // A final reason Rust doesn't allow us to index into a `String` is that it isn't possible to
    // guarantee that O(1) performance with a `String`.

    // Slicing Strings
    // Rather than indexing using `[]` with a single number, we can use `[]` with a range to create
    // a string slice containing particular bytes.
    let hello = "Здравствуйте";
    let s = &hello[0..4];
    println!("{}", s);  // Зд

    // If we were to try to slice only part of a character's bytes with something like `&hello[0..1]`,
    // Rust would panic at runtime.
    // let s = &hello[0..1];  // Panic!

    let s = "我是傻狗";
    println!("{}", s.len());  // 12.
    println!("{}", &s[6..9]);

    // Methods for Iterating Over Strings
    // The best way to operate on pieces of strings is to be explicit about whether we want
    // characters or bytes. For individual Unicode scalar values, use the `chars` method.
    for c in "नमस्ते".chars() {
        println!("{}", c);
    }

    // Alternatively, the `bytes` method returns each raw byte, which might be appropriate for our
    // domain:
    for b in "नमस्ते".bytes() {
        println!("{}", b);
    }

    // Getting grapheme clusters from strings is complex, so this functionality is not provided
    // by the standard library.
}
